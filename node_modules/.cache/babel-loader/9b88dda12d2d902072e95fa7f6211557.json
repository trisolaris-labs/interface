{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { useContext } from 'react';\nimport HTML from 'html-parse-stringify2';\nimport { getI18n, getHasUsedI18nextProvider, I18nContext, getDefaults } from './context';\nimport { warn, warnOnce } from './utils';\n\nfunction hasChildren(node) {\n  return node && (node.children || node.props && node.props.children);\n}\n\nfunction getChildren(node) {\n  if (!node) return [];\n  return node && node.children ? node.children : node.props && node.props.children;\n}\n\nfunction hasValidReactChildren(children) {\n  if (Object.prototype.toString.call(children) !== '[object Array]') return false;\n  return children.every(function (child) {\n    return React.isValidElement(child);\n  });\n}\n\nfunction getAsArray(data) {\n  return Array.isArray(data) ? data : [data];\n}\n\nexport function nodesToString(startingString, children, index, i18nOptions) {\n  if (!children) return '';\n  var stringNode = startingString;\n  var childrenArray = getAsArray(children);\n  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  childrenArray.forEach(function (child, i) {\n    var elementKey = \"\".concat(i);\n\n    if (typeof child === 'string') {\n      stringNode = \"\".concat(stringNode).concat(child);\n    } else if (hasChildren(child)) {\n      var elementTag = keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 1 && typeof hasChildren(child) === 'string' ? child.type : elementKey;\n\n      if (child.props && child.props.i18nIsDynamicList) {\n        // we got a dynamic list like \"<ul>{['a', 'b'].map(item => ( <li key={item}>{item}</li> ))}</ul>\"\"\n        // the result should be \"<0></0>\" and not \"<0><0>a</0><1>b</1></0>\"\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementTag, \"></\").concat(elementTag, \">\");\n      } else {\n        // regular case mapping the inner children\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementTag, \">\").concat(nodesToString('', getChildren(child), i + 1, i18nOptions), \"</\").concat(elementTag, \">\");\n      }\n    } else if (React.isValidElement(child)) {\n      if (keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 0) {\n        stringNode = \"\".concat(stringNode, \"<\").concat(child.type, \"/>\");\n      } else {\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementKey, \"></\").concat(elementKey, \">\");\n      }\n    } else if (_typeof(child) === 'object') {\n      var clone = _objectSpread({}, child);\n\n      var format = clone.format;\n      delete clone.format;\n      var keys = Object.keys(clone);\n\n      if (format && keys.length === 1) {\n        stringNode = \"\".concat(stringNode, \"{{\").concat(keys[0], \", \").concat(format, \"}}\");\n      } else if (keys.length === 1) {\n        stringNode = \"\".concat(stringNode, \"{{\").concat(keys[0], \"}}\");\n      } else {\n        // not a valid interpolation object (can only contain one value plus format)\n        warn(\"react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.\", child);\n      }\n    } else {\n      warn(\"Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.\", child);\n    }\n  });\n  return stringNode;\n}\n\nfunction renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts) {\n  if (targetString === '') return []; // check if contains tags we need to replace from html string to react nodes\n\n  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join('|')).test(targetString); // no need to replace tags in the targetstring\n\n  if (!children && !emptyChildrenButNeedsHandling) return [targetString]; // v2 -> interpolates upfront no need for \"some <0>{{var}}</0>\"\" -> will be just \"some {{var}}\" in translation file\n\n  var data = {};\n\n  function getData(childs) {\n    var childrenArray = getAsArray(childs);\n    childrenArray.forEach(function (child) {\n      if (typeof child === 'string') return;\n      if (hasChildren(child)) getData(getChildren(child));else if (_typeof(child) === 'object' && !React.isValidElement(child)) Object.assign(data, child);\n    });\n  }\n\n  getData(children);\n  var interpolatedString = i18n.services.interpolator.interpolate(targetString, _objectSpread({}, data, {}, combinedTOpts), i18n.language); // parse ast from string with additional wrapper tag\n  // -> avoids issues in parser removing prepending text nodes\n\n  var ast = HTML.parse(\"<0>\".concat(interpolatedString, \"</0>\"));\n\n  function mapAST(reactNode, astNode) {\n    var reactNodes = getAsArray(reactNode);\n    var astNodes = getAsArray(astNode);\n    return astNodes.reduce(function (mem, node, i) {\n      var translationContent = node.children && node.children[0] && node.children[0].content;\n\n      if (node.type === 'tag') {\n        var child = reactNodes[parseInt(node.name, 10)] || {};\n        var isElement = React.isValidElement(child);\n\n        if (typeof child === 'string') {\n          mem.push(child);\n        } else if (hasChildren(child)) {\n          var childs = getChildren(child);\n          var mappedChildren = mapAST(childs, node.children);\n          var inner = hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;\n          if (child.dummy) child.children = inner; // needed on preact!\n\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), inner));\n        } else if (emptyChildrenButNeedsHandling && _typeof(child) === 'object' && child.dummy && !isElement) {\n          // we have a empty Trans node (the dummy element) with a targetstring that contains html tags needing\n          // conversion to react nodes\n          // so we just need to map the inner stuff\n          var _inner = mapAST(reactNodes\n          /* wrong but we need something */\n          , node.children);\n\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), _inner));\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(React.createElement(node.name, {\n                key: \"\".concat(node.name, \"-\").concat(i)\n              }));\n            } else {\n              var _inner2 = mapAST(reactNodes\n              /* wrong but we need something */\n              , node.children);\n\n              mem.push(React.createElement(node.name, {\n                key: \"\".concat(node.name, \"-\").concat(i)\n              }, _inner2));\n            }\n          } else if (node.voidElement) {\n            mem.push(\"<\".concat(node.name, \" />\"));\n          } else {\n            var _inner3 = mapAST(reactNodes\n            /* wrong but we need something */\n            , node.children);\n\n            mem.push(\"<\".concat(node.name, \">\").concat(_inner3, \"</\").concat(node.name, \">\"));\n          }\n        } else if (_typeof(child) === 'object' && !isElement) {\n          var content = node.children[0] ? translationContent : null; // v1\n          // as interpolation was done already we just have a regular content node\n          // in the translation AST while having an object in reactNodes\n          // -> push the content no need to interpolate again\n\n          if (content) mem.push(content);\n        } else if (node.children.length === 1 && translationContent) {\n          // If component does not have children, but translation - has\n          // with this in component could be components={[<span class='make-beautiful'/>]} and in translation - 'some text <0>some highlighted message</0>'\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), translationContent));\n        } else {\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          })));\n        }\n      } else if (node.type === 'text') {\n        mem.push(node.content);\n      }\n\n      return mem;\n    }, []);\n  } // call mapAST with having react nodes nested into additional node like\n  // we did for the string ast from translation\n  // return the children of that extra node to get expected result\n\n\n  var result = mapAST([{\n    dummy: true,\n    children: children\n  }], ast);\n  return getChildren(result[0]);\n}\n\nexport function Trans(_ref) {\n  var children = _ref.children,\n      count = _ref.count,\n      parent = _ref.parent,\n      i18nKey = _ref.i18nKey,\n      tOptions = _ref.tOptions,\n      values = _ref.values,\n      defaults = _ref.defaults,\n      components = _ref.components,\n      ns = _ref.ns,\n      i18nFromProps = _ref.i18n,\n      tFromProps = _ref.t,\n      additionalProps = _objectWithoutProperties(_ref, [\"children\", \"count\", \"parent\", \"i18nKey\", \"tOptions\", \"values\", \"defaults\", \"components\", \"ns\", \"i18n\", \"t\"]);\n\n  var _ref2 = getHasUsedI18nextProvider() ? useContext(I18nContext) || {} : {},\n      i18nFromContext = _ref2.i18n,\n      defaultNSFromContext = _ref2.defaultNS;\n\n  var i18n = i18nFromProps || i18nFromContext || getI18n();\n\n  if (!i18n) {\n    warnOnce('You will need pass in an i18next instance by using i18nextReactModule');\n    return children;\n  }\n\n  var t = tFromProps || i18n.t.bind(i18n) || function (k) {\n    return k;\n  };\n\n  var reactI18nextOptions = _objectSpread({}, getDefaults(), {}, i18n.options && i18n.options.react);\n\n  var useAsParent = parent !== undefined ? parent : reactI18nextOptions.defaultTransParent; // prepare having a namespace\n\n  var namespaces = ns || t.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;\n  namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];\n  var defaultValue = defaults || nodesToString('', children, 0, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue;\n  var hashTransKey = reactI18nextOptions.hashTransKey;\n  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);\n  var interpolationOverride = values ? {} : {\n    interpolation: {\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n\n  var combinedTOpts = _objectSpread({}, tOptions, {\n    count: count\n  }, values, {}, interpolationOverride, {\n    defaultValue: defaultValue,\n    ns: namespaces\n  });\n\n  var translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (!useAsParent) return renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts);\n  return React.createElement(useAsParent, additionalProps, renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts));\n}","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/node_modules/react-i18next/dist/es/Trans.js"],"names":["_objectWithoutProperties","_defineProperty","_typeof","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","React","useContext","HTML","getI18n","getHasUsedI18nextProvider","I18nContext","getDefaults","warn","warnOnce","hasChildren","node","children","props","getChildren","hasValidReactChildren","prototype","toString","call","every","child","isValidElement","getAsArray","data","Array","isArray","nodesToString","startingString","index","i18nOptions","stringNode","childrenArray","keepArray","transKeepBasicHtmlNodesFor","elementKey","concat","elementTag","indexOf","type","i18nIsDynamicList","clone","format","renderNodes","targetString","i18n","combinedTOpts","emptyChildrenButNeedsHandling","RegExp","join","test","getData","childs","assign","interpolatedString","services","interpolator","interpolate","language","ast","parse","mapAST","reactNode","astNode","reactNodes","astNodes","reduce","mem","translationContent","content","parseInt","name","isElement","mappedChildren","inner","dummy","cloneElement","_inner","Number","isNaN","parseFloat","transSupportBasicHtmlNodes","voidElement","createElement","_inner2","_inner3","result","Trans","_ref","count","parent","i18nKey","tOptions","values","defaults","components","ns","i18nFromProps","tFromProps","t","additionalProps","_ref2","i18nFromContext","defaultNSFromContext","defaultNS","bind","k","reactI18nextOptions","options","react","useAsParent","undefined","defaultTransParent","namespaces","defaultValue","transEmptyNodeValue","hashTransKey","interpolationOverride","interpolation","prefix","suffix","translation"],"mappings":"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","sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useContext } from 'react';\nimport HTML from 'html-parse-stringify2';\nimport { getI18n, getHasUsedI18nextProvider, I18nContext, getDefaults } from './context';\nimport { warn, warnOnce } from './utils';\n\nfunction hasChildren(node) {\n  return node && (node.children || node.props && node.props.children);\n}\n\nfunction getChildren(node) {\n  if (!node) return [];\n  return node && node.children ? node.children : node.props && node.props.children;\n}\n\nfunction hasValidReactChildren(children) {\n  if (Object.prototype.toString.call(children) !== '[object Array]') return false;\n  return children.every(function (child) {\n    return React.isValidElement(child);\n  });\n}\n\nfunction getAsArray(data) {\n  return Array.isArray(data) ? data : [data];\n}\n\nexport function nodesToString(startingString, children, index, i18nOptions) {\n  if (!children) return '';\n  var stringNode = startingString;\n  var childrenArray = getAsArray(children);\n  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  childrenArray.forEach(function (child, i) {\n    var elementKey = \"\".concat(i);\n\n    if (typeof child === 'string') {\n      stringNode = \"\".concat(stringNode).concat(child);\n    } else if (hasChildren(child)) {\n      var elementTag = keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 1 && typeof hasChildren(child) === 'string' ? child.type : elementKey;\n\n      if (child.props && child.props.i18nIsDynamicList) {\n        // we got a dynamic list like \"<ul>{['a', 'b'].map(item => ( <li key={item}>{item}</li> ))}</ul>\"\"\n        // the result should be \"<0></0>\" and not \"<0><0>a</0><1>b</1></0>\"\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementTag, \"></\").concat(elementTag, \">\");\n      } else {\n        // regular case mapping the inner children\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementTag, \">\").concat(nodesToString('', getChildren(child), i + 1, i18nOptions), \"</\").concat(elementTag, \">\");\n      }\n    } else if (React.isValidElement(child)) {\n      if (keepArray.indexOf(child.type) > -1 && Object.keys(child.props).length === 0) {\n        stringNode = \"\".concat(stringNode, \"<\").concat(child.type, \"/>\");\n      } else {\n        stringNode = \"\".concat(stringNode, \"<\").concat(elementKey, \"></\").concat(elementKey, \">\");\n      }\n    } else if (_typeof(child) === 'object') {\n      var clone = _objectSpread({}, child);\n\n      var format = clone.format;\n      delete clone.format;\n      var keys = Object.keys(clone);\n\n      if (format && keys.length === 1) {\n        stringNode = \"\".concat(stringNode, \"{{\").concat(keys[0], \", \").concat(format, \"}}\");\n      } else if (keys.length === 1) {\n        stringNode = \"\".concat(stringNode, \"{{\").concat(keys[0], \"}}\");\n      } else {\n        // not a valid interpolation object (can only contain one value plus format)\n        warn(\"react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.\", child);\n      }\n    } else {\n      warn(\"Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.\", child);\n    }\n  });\n  return stringNode;\n}\n\nfunction renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts) {\n  if (targetString === '') return []; // check if contains tags we need to replace from html string to react nodes\n\n  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  var emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join('|')).test(targetString); // no need to replace tags in the targetstring\n\n  if (!children && !emptyChildrenButNeedsHandling) return [targetString]; // v2 -> interpolates upfront no need for \"some <0>{{var}}</0>\"\" -> will be just \"some {{var}}\" in translation file\n\n  var data = {};\n\n  function getData(childs) {\n    var childrenArray = getAsArray(childs);\n    childrenArray.forEach(function (child) {\n      if (typeof child === 'string') return;\n      if (hasChildren(child)) getData(getChildren(child));else if (_typeof(child) === 'object' && !React.isValidElement(child)) Object.assign(data, child);\n    });\n  }\n\n  getData(children);\n  var interpolatedString = i18n.services.interpolator.interpolate(targetString, _objectSpread({}, data, {}, combinedTOpts), i18n.language); // parse ast from string with additional wrapper tag\n  // -> avoids issues in parser removing prepending text nodes\n\n  var ast = HTML.parse(\"<0>\".concat(interpolatedString, \"</0>\"));\n\n  function mapAST(reactNode, astNode) {\n    var reactNodes = getAsArray(reactNode);\n    var astNodes = getAsArray(astNode);\n    return astNodes.reduce(function (mem, node, i) {\n      var translationContent = node.children && node.children[0] && node.children[0].content;\n\n      if (node.type === 'tag') {\n        var child = reactNodes[parseInt(node.name, 10)] || {};\n        var isElement = React.isValidElement(child);\n\n        if (typeof child === 'string') {\n          mem.push(child);\n        } else if (hasChildren(child)) {\n          var childs = getChildren(child);\n          var mappedChildren = mapAST(childs, node.children);\n          var inner = hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;\n          if (child.dummy) child.children = inner; // needed on preact!\n\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), inner));\n        } else if (emptyChildrenButNeedsHandling && _typeof(child) === 'object' && child.dummy && !isElement) {\n          // we have a empty Trans node (the dummy element) with a targetstring that contains html tags needing\n          // conversion to react nodes\n          // so we just need to map the inner stuff\n          var _inner = mapAST(reactNodes\n          /* wrong but we need something */\n          , node.children);\n\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), _inner));\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push(React.createElement(node.name, {\n                key: \"\".concat(node.name, \"-\").concat(i)\n              }));\n            } else {\n              var _inner2 = mapAST(reactNodes\n              /* wrong but we need something */\n              , node.children);\n\n              mem.push(React.createElement(node.name, {\n                key: \"\".concat(node.name, \"-\").concat(i)\n              }, _inner2));\n            }\n          } else if (node.voidElement) {\n            mem.push(\"<\".concat(node.name, \" />\"));\n          } else {\n            var _inner3 = mapAST(reactNodes\n            /* wrong but we need something */\n            , node.children);\n\n            mem.push(\"<\".concat(node.name, \">\").concat(_inner3, \"</\").concat(node.name, \">\"));\n          }\n        } else if (_typeof(child) === 'object' && !isElement) {\n          var content = node.children[0] ? translationContent : null; // v1\n          // as interpolation was done already we just have a regular content node\n          // in the translation AST while having an object in reactNodes\n          // -> push the content no need to interpolate again\n\n          if (content) mem.push(content);\n        } else if (node.children.length === 1 && translationContent) {\n          // If component does not have children, but translation - has\n          // with this in component could be components={[<span class='make-beautiful'/>]} and in translation - 'some text <0>some highlighted message</0>'\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          }), translationContent));\n        } else {\n          mem.push(React.cloneElement(child, _objectSpread({}, child.props, {\n            key: i\n          })));\n        }\n      } else if (node.type === 'text') {\n        mem.push(node.content);\n      }\n\n      return mem;\n    }, []);\n  } // call mapAST with having react nodes nested into additional node like\n  // we did for the string ast from translation\n  // return the children of that extra node to get expected result\n\n\n  var result = mapAST([{\n    dummy: true,\n    children: children\n  }], ast);\n  return getChildren(result[0]);\n}\n\nexport function Trans(_ref) {\n  var children = _ref.children,\n      count = _ref.count,\n      parent = _ref.parent,\n      i18nKey = _ref.i18nKey,\n      tOptions = _ref.tOptions,\n      values = _ref.values,\n      defaults = _ref.defaults,\n      components = _ref.components,\n      ns = _ref.ns,\n      i18nFromProps = _ref.i18n,\n      tFromProps = _ref.t,\n      additionalProps = _objectWithoutProperties(_ref, [\"children\", \"count\", \"parent\", \"i18nKey\", \"tOptions\", \"values\", \"defaults\", \"components\", \"ns\", \"i18n\", \"t\"]);\n\n  var _ref2 = getHasUsedI18nextProvider() ? useContext(I18nContext) || {} : {},\n      i18nFromContext = _ref2.i18n,\n      defaultNSFromContext = _ref2.defaultNS;\n\n  var i18n = i18nFromProps || i18nFromContext || getI18n();\n\n  if (!i18n) {\n    warnOnce('You will need pass in an i18next instance by using i18nextReactModule');\n    return children;\n  }\n\n  var t = tFromProps || i18n.t.bind(i18n) || function (k) {\n    return k;\n  };\n\n  var reactI18nextOptions = _objectSpread({}, getDefaults(), {}, i18n.options && i18n.options.react);\n\n  var useAsParent = parent !== undefined ? parent : reactI18nextOptions.defaultTransParent; // prepare having a namespace\n\n  var namespaces = ns || t.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;\n  namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];\n  var defaultValue = defaults || nodesToString('', children, 0, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue;\n  var hashTransKey = reactI18nextOptions.hashTransKey;\n  var key = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue);\n  var interpolationOverride = values ? {} : {\n    interpolation: {\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n\n  var combinedTOpts = _objectSpread({}, tOptions, {\n    count: count\n  }, values, {}, interpolationOverride, {\n    defaultValue: defaultValue,\n    ns: namespaces\n  });\n\n  var translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (!useAsParent) return renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts);\n  return React.createElement(useAsParent, additionalProps, renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts));\n}"]},"metadata":{},"sourceType":"module"}