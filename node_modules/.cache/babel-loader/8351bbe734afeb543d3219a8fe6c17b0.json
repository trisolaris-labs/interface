{"ast":null,"code":"/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\n\n/*jslint\r\n    white: true,\r\n    vars: true,\r\n    node: true\r\n*/\nfunction ObjectMergeOptions(opts) {\n  'use strict';\n\n  opts = opts || {};\n  this.depth = opts.depth || false; // circular ref check is true unless explicitly set to false\n  // ignore the jslint warning here, it's pointless.\n\n  this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\n}\n/*jslint unparam:true*/\n\n/**\r\n * Creates a new options object suitable for use with objectMerge.\r\n * @memberOf objectMerge\r\n * @param {Object} [opts] An object specifying the options.\r\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\r\n *  during merging. If this is set to false then there will be no depth limit.\r\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\r\n *  errors on circular references.\r\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\r\n *  to be used with objectMerge.\r\n * @example\r\n *  var opts = objectMerge.createOptions({\r\n *      depth : 2,\r\n *      throwOnCircularRef : false\r\n *  });\r\n *  var obj1 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : {}\r\n *          }\r\n *      }\r\n *  };\r\n *  var obj2 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : 'will not be in output'\r\n *          },\r\n *          a22 : {}\r\n *      }\r\n *  };\r\n *  objectMerge(opts, obj1, obj2);\r\n */\n\n\nfunction createOptions(opts) {\n  'use strict';\n\n  var argz = Array.prototype.slice.call(arguments, 0);\n  argz.unshift(null);\n  var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\n  return new F();\n}\n/*jslint unparam:false*/\n\n/**\r\n * Merges JavaScript objects recursively without altering the objects merged.\r\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {ObjectMergeOptions} [opts] An options object created by \r\n *  objectMerge.createOptions. Options must be specified as the first argument\r\n *  and must be an object created with createOptions or else the object will\r\n *  not be recognized as an options object and will be merged instead.\r\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\r\n *  argument given will be treated as an object to merge. Each object\r\n *  overwrites the previous objects descendant properties if the property name\r\n *  matches. If objects properties are objects they will be merged recursively\r\n *  as well.\r\n * @returns {Object} Returns a single merged object composed from clones of the\r\n *  input objects.\r\n * @example\r\n *  var objectMerge = require('object-merge');\r\n *  var x = {\r\n *      a : 'a',\r\n *      b : 'b',\r\n *      c : {\r\n *          d : 'd',\r\n *          e : 'e',\r\n *          f : {\r\n *              g : 'g'\r\n *          }\r\n *      }\r\n *  };\r\n *  var y = {\r\n *      a : '`a',\r\n *      b : '`b',\r\n *      c : {\r\n *          d : '`d'\r\n *      }\r\n *  };\r\n *  var z = {\r\n *      a : {\r\n *          b : '``b'\r\n *      },\r\n *      fun : function foo () {\r\n *          return 'foo';\r\n *      },\r\n *      aps : Array.prototype.slice\r\n *  };\r\n *  var out = objectMerge(x, y, z);\r\n *  // out.a will be {\r\n *  //         b : '``b'\r\n *  //     }\r\n *  // out.b will be '`b'\r\n *  // out.c will be {\r\n *  //         d : '`d',\r\n *  //         e : 'e',\r\n *  //         f : {\r\n *  //             g : 'g'\r\n *  //         }\r\n *  //     }\r\n *  // out.fun will be a clone of z.fun\r\n *  // out.aps will be equal to z.aps\r\n */\n\n\nfunction objectMerge(shadows) {\n  'use strict';\n\n  var objectForeach = require('object-foreach');\n\n  var cloneFunction = require('clone-function'); // this is the queue of visited objects / properties.\n\n\n  var visited = []; // various merge options\n\n  var options = {}; // gets the sequential trailing objects from array.\n\n  function getShadowObjects(shadows) {\n    var out = shadows.reduce(function (collector, shadow) {\n      if (shadow instanceof Object) {\n        collector.push(shadow);\n      } else {\n        collector = [];\n      }\n\n      return collector;\n    }, []);\n    return out;\n  } // gets either a new object of the proper type or the last primitive value\n\n\n  function getOutputObject(shadows) {\n    var out;\n    var lastShadow = shadows[shadows.length - 1];\n\n    if (lastShadow instanceof Array) {\n      out = [];\n    } else if (lastShadow instanceof Function) {\n      try {\n        out = cloneFunction(lastShadow);\n      } catch (e) {\n        throw new Error(e.message);\n      }\n    } else if (lastShadow instanceof Object) {\n      out = {};\n    } else {\n      // lastShadow is a primitive value;\n      out = lastShadow;\n    }\n\n    return out;\n  } // checks for circular references\n\n\n  function circularReferenceCheck(shadows) {\n    // if any of the current objects to process exist in the queue\n    // then throw an error.\n    shadows.forEach(function (item) {\n      if (item instanceof Object && visited.indexOf(item) > -1) {\n        throw new Error('Circular reference error');\n      }\n    }); // if none of the current objects were in the queue\n    // then add references to the queue.\n\n    visited = visited.concat(shadows);\n  }\n\n  function objectMergeRecursor(shadows, currentDepth) {\n    if (options.depth !== false) {\n      currentDepth = currentDepth ? currentDepth + 1 : 1;\n    } else {\n      currentDepth = 0;\n    }\n\n    if (options.throwOnCircularRef === true) {\n      circularReferenceCheck(shadows);\n    }\n\n    var out = getOutputObject(shadows);\n    /*jslint unparam: true */\n\n    function shadowHandler(val, prop, shadow) {\n      if (out[prop]) {\n        out[prop] = objectMergeRecursor([out[prop], shadow[prop]], currentDepth);\n      } else {\n        out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\n      }\n    }\n    /*jslint unparam:false */\n\n\n    function shadowMerger(shadow) {\n      objectForeach(shadow, shadowHandler);\n    } // short circuits case where output would be a primitive value\n    // anyway.\n\n\n    if (out instanceof Object && currentDepth <= options.depth) {\n      // only merges trailing objects since primitives would wipe out\n      // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\n      // would result in {b:'b'} so the first two arguments\n      // can be ignored completely.\n      var relevantShadows = getShadowObjects(shadows);\n      relevantShadows.forEach(shadowMerger);\n    }\n\n    return out;\n  } // determines whether an options object was passed in and\n  // uses it if present\n  // ignore the jslint warning here too.\n\n\n  if (arguments[0] instanceof ObjectMergeOptions) {\n    options = arguments[0];\n    shadows = Array.prototype.slice.call(arguments, 1);\n  } else {\n    options = createOptions();\n    shadows = Array.prototype.slice.call(arguments, 0);\n  }\n\n  return objectMergeRecursor(shadows);\n}\n\nobjectMerge.createOptions = createOptions;\nmodule.exports = objectMerge;","map":{"version":3,"sources":["/Users/sidshekhar/Documents/interface/node_modules/object-merge/src/object-merge.js"],"names":["ObjectMergeOptions","opts","depth","throwOnCircularRef","createOptions","argz","Array","prototype","slice","call","arguments","unshift","F","bind","apply","objectMerge","shadows","objectForeach","require","cloneFunction","visited","options","getShadowObjects","out","reduce","collector","shadow","Object","push","getOutputObject","lastShadow","length","Function","e","Error","message","circularReferenceCheck","forEach","item","indexOf","concat","objectMergeRecursor","currentDepth","shadowHandler","val","prop","shadowMerger","relevantShadows","module","exports"],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAT,CAA4BC,IAA5B,EAAkC;AAC9B;;AACAA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,OAAKC,KAAL,GAAaD,IAAI,CAACC,KAAL,IAAc,KAA3B,CAH8B,CAI9B;AACA;;AACA,OAAKC,kBAAL,GAA0B,wBAAwBF,IAAxB,IAAgCA,IAAI,CAACE,kBAAL,KAA4B,KAA5D,GAAoE,KAApE,GAA4E,IAAtG;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAuBH,IAAvB,EAA6B;AACzB;;AACA,MAAII,IAAI,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAX;AACAL,EAAAA,IAAI,CAACM,OAAL,CAAa,IAAb;AACA,MAAIC,CAAC,GAAGZ,kBAAkB,CAACa,IAAnB,CAAwBC,KAAxB,CAA8Bd,kBAA9B,EAAkDK,IAAlD,CAAR;AACA,SAAO,IAAIO,CAAJ,EAAP;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBC,OAArB,EAA8B;AAC1B;;AACA,MAAIC,aAAa,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAIC,aAAa,GAAGD,OAAO,CAAC,gBAAD,CAA3B,CAH0B,CAI1B;;;AA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","sourcesContent":["/*\r\nLicense gpl-3.0 http://www.gnu.org/licenses/gpl-3.0-standalone.html\r\n*/\r\n/*jslint\r\n    white: true,\r\n    vars: true,\r\n    node: true\r\n*/\r\nfunction ObjectMergeOptions(opts) {\r\n    'use strict';\r\n    opts = opts || {};\r\n    this.depth = opts.depth || false;\r\n    // circular ref check is true unless explicitly set to false\r\n    // ignore the jslint warning here, it's pointless.\r\n    this.throwOnCircularRef = 'throwOnCircularRef' in opts && opts.throwOnCircularRef === false ? false : true;\r\n}\r\n/*jslint unparam:true*/\r\n/**\r\n * Creates a new options object suitable for use with objectMerge.\r\n * @memberOf objectMerge\r\n * @param {Object} [opts] An object specifying the options.\r\n * @param {Object} [opts.depth = false] Specifies the depth to traverse objects\r\n *  during merging. If this is set to false then there will be no depth limit.\r\n * @param {Object} [opts.throwOnCircularRef = true] Set to false to suppress\r\n *  errors on circular references.\r\n * @returns {ObjectMergeOptions} Returns an instance of ObjectMergeOptions\r\n *  to be used with objectMerge.\r\n * @example\r\n *  var opts = objectMerge.createOptions({\r\n *      depth : 2,\r\n *      throwOnCircularRef : false\r\n *  });\r\n *  var obj1 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : {}\r\n *          }\r\n *      }\r\n *  };\r\n *  var obj2 = {\r\n *      a1 : {\r\n *          a2 : {\r\n *              a3 : 'will not be in output'\r\n *          },\r\n *          a22 : {}\r\n *      }\r\n *  };\r\n *  objectMerge(opts, obj1, obj2);\r\n */\r\nfunction createOptions(opts) {\r\n    'use strict';\r\n    var argz = Array.prototype.slice.call(arguments, 0);\r\n    argz.unshift(null);\r\n    var F = ObjectMergeOptions.bind.apply(ObjectMergeOptions, argz);\r\n    return new F();\r\n}\r\n/*jslint unparam:false*/\r\n/**\r\n * Merges JavaScript objects recursively without altering the objects merged.\r\n * @namespace Merges JavaScript objects recursively without altering the objects merged.\r\n * @author <a href=\"mailto:matthewkastor@gmail.com\">Matthew Kastor</a>\r\n * @param {ObjectMergeOptions} [opts] An options object created by \r\n *  objectMerge.createOptions. Options must be specified as the first argument\r\n *  and must be an object created with createOptions or else the object will\r\n *  not be recognized as an options object and will be merged instead.\r\n * @param {Object} shadows [[shadows]...] One or more objects to merge. Each\r\n *  argument given will be treated as an object to merge. Each object\r\n *  overwrites the previous objects descendant properties if the property name\r\n *  matches. If objects properties are objects they will be merged recursively\r\n *  as well.\r\n * @returns {Object} Returns a single merged object composed from clones of the\r\n *  input objects.\r\n * @example\r\n *  var objectMerge = require('object-merge');\r\n *  var x = {\r\n *      a : 'a',\r\n *      b : 'b',\r\n *      c : {\r\n *          d : 'd',\r\n *          e : 'e',\r\n *          f : {\r\n *              g : 'g'\r\n *          }\r\n *      }\r\n *  };\r\n *  var y = {\r\n *      a : '`a',\r\n *      b : '`b',\r\n *      c : {\r\n *          d : '`d'\r\n *      }\r\n *  };\r\n *  var z = {\r\n *      a : {\r\n *          b : '``b'\r\n *      },\r\n *      fun : function foo () {\r\n *          return 'foo';\r\n *      },\r\n *      aps : Array.prototype.slice\r\n *  };\r\n *  var out = objectMerge(x, y, z);\r\n *  // out.a will be {\r\n *  //         b : '``b'\r\n *  //     }\r\n *  // out.b will be '`b'\r\n *  // out.c will be {\r\n *  //         d : '`d',\r\n *  //         e : 'e',\r\n *  //         f : {\r\n *  //             g : 'g'\r\n *  //         }\r\n *  //     }\r\n *  // out.fun will be a clone of z.fun\r\n *  // out.aps will be equal to z.aps\r\n */\r\nfunction objectMerge(shadows) {\r\n    'use strict';\r\n    var objectForeach = require('object-foreach');\r\n    var cloneFunction = require('clone-function');\r\n    // this is the queue of visited objects / properties.\r\n    var visited = [];\r\n    // various merge options\r\n    var options = {};\r\n    // gets the sequential trailing objects from array.\r\n    function getShadowObjects(shadows) {\r\n        var out = shadows.reduce(function (collector, shadow) {\r\n                if (shadow instanceof Object) {\r\n                    collector.push(shadow);\r\n                } else {\r\n                    collector = [];\r\n                }\r\n                return collector;\r\n            }, []);\r\n        return out;\r\n    }\r\n    // gets either a new object of the proper type or the last primitive value\r\n    function getOutputObject(shadows) {\r\n        var out;\r\n        var lastShadow = shadows[shadows.length - 1];\r\n        if (lastShadow instanceof Array) {\r\n            out = [];\r\n        } else if (lastShadow instanceof Function) {\r\n            try {\r\n                out = cloneFunction(lastShadow);\r\n            } catch (e) {\r\n                throw new Error(e.message);\r\n            }\r\n        } else if (lastShadow instanceof Object) {\r\n            out = {};\r\n        } else {\r\n            // lastShadow is a primitive value;\r\n            out = lastShadow;\r\n        }\r\n        return out;\r\n    }\r\n    // checks for circular references\r\n    function circularReferenceCheck(shadows) {\r\n        // if any of the current objects to process exist in the queue\r\n        // then throw an error.\r\n        shadows.forEach(function (item) {\r\n            if (item instanceof Object && visited.indexOf(item) > -1) {\r\n                throw new Error('Circular reference error');\r\n            }\r\n        });\r\n        // if none of the current objects were in the queue\r\n        // then add references to the queue.\r\n        visited = visited.concat(shadows);\r\n    }\r\n    function objectMergeRecursor(shadows, currentDepth) {\r\n        if (options.depth !== false) {\r\n            currentDepth = currentDepth ? currentDepth + 1 : 1;\r\n        } else {\r\n            currentDepth = 0;\r\n        }\r\n        if (options.throwOnCircularRef === true) {\r\n            circularReferenceCheck(shadows);\r\n        }\r\n        var out = getOutputObject(shadows);\r\n        /*jslint unparam: true */\r\n        function shadowHandler(val, prop, shadow) {\r\n            if (out[prop]) {\r\n                out[prop] = objectMergeRecursor([\r\n                    out[prop],\r\n                    shadow[prop]\r\n                ], currentDepth);\r\n            } else {\r\n                out[prop] = objectMergeRecursor([shadow[prop]], currentDepth);\r\n            }\r\n        }\r\n        /*jslint unparam:false */\r\n        function shadowMerger(shadow) {\r\n            objectForeach(shadow, shadowHandler);\r\n        }\r\n        // short circuits case where output would be a primitive value\r\n        // anyway.\r\n        if (out instanceof Object && currentDepth <= options.depth) {\r\n            // only merges trailing objects since primitives would wipe out\r\n            // previous objects, as in merging {a:'a'}, 'a', and {b:'b'}\r\n            // would result in {b:'b'} so the first two arguments\r\n            // can be ignored completely.\r\n            var relevantShadows = getShadowObjects(shadows);\r\n            relevantShadows.forEach(shadowMerger);\r\n        }\r\n        return out;\r\n    }\r\n    // determines whether an options object was passed in and\r\n    // uses it if present\r\n    // ignore the jslint warning here too.\r\n    if (arguments[0] instanceof ObjectMergeOptions) {\r\n        options = arguments[0];\r\n        shadows = Array.prototype.slice.call(arguments, 1);\r\n    } else {\r\n        options = createOptions();\r\n        shadows = Array.prototype.slice.call(arguments, 0);\r\n    }\r\n    return objectMergeRecursor(shadows);\r\n}\r\nobjectMerge.createOptions = createOptions;\r\nmodule.exports = objectMerge;"]},"metadata":{},"sourceType":"script"}